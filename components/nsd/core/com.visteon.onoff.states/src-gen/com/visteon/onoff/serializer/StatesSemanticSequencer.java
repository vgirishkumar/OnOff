/*
 * generated by Xtext 2.13.0
 */
package com.visteon.onoff.serializer;

import com.google.inject.Inject;
import com.visteon.onoff.services.StatesGrammarAccess;
import com.visteon.onoff.states.ClientConfiguration;
import com.visteon.onoff.states.ComponentState;
import com.visteon.onoff.states.ComponentTransition;
import com.visteon.onoff.states.Feature;
import com.visteon.onoff.states.FeatureDependency;
import com.visteon.onoff.states.Import;
import com.visteon.onoff.states.NodeState;
import com.visteon.onoff.states.NodeStateAssociation;
import com.visteon.onoff.states.NodeStateConfiguration;
import com.visteon.onoff.states.NodeStateDiagram;
import com.visteon.onoff.states.NodeTransition;
import com.visteon.onoff.states.StateDependency;
import com.visteon.onoff.states.StatesPackage;
import com.visteon.onoff.states.TransitionDependency;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class StatesSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private StatesGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == StatesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StatesPackage.CLIENT_CONFIGURATION:
				sequence_ClientConfiguration(context, (ClientConfiguration) semanticObject); 
				return; 
			case StatesPackage.COMPONENT_STATE:
				sequence_ComponentState(context, (ComponentState) semanticObject); 
				return; 
			case StatesPackage.COMPONENT_TRANSITION:
				sequence_ComponentTransition(context, (ComponentTransition) semanticObject); 
				return; 
			case StatesPackage.FEATURE:
				sequence_Feature(context, (Feature) semanticObject); 
				return; 
			case StatesPackage.FEATURE_DEPENDENCY:
				sequence_FeatureDependency(context, (FeatureDependency) semanticObject); 
				return; 
			case StatesPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case StatesPackage.NODE_STATE:
				sequence_NodeState(context, (NodeState) semanticObject); 
				return; 
			case StatesPackage.NODE_STATE_ASSOCIATION:
				sequence_NodeStateAssociation(context, (NodeStateAssociation) semanticObject); 
				return; 
			case StatesPackage.NODE_STATE_CONFIGURATION:
				sequence_NodeStateConfiguration(context, (NodeStateConfiguration) semanticObject); 
				return; 
			case StatesPackage.NODE_STATE_DIAGRAM:
				sequence_NodeStateDiagram(context, (NodeStateDiagram) semanticObject); 
				return; 
			case StatesPackage.NODE_TRANSITION:
				sequence_NodeTransition(context, (NodeTransition) semanticObject); 
				return; 
			case StatesPackage.STATE_DEPENDENCY:
				sequence_StateDependency(context, (StateDependency) semanticObject); 
				return; 
			case StatesPackage.TRANSITION_DEPENDENCY:
				sequence_TransitionDependency(context, (TransitionDependency) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ClientConfiguration returns ClientConfiguration
	 *
	 * Constraint:
	 *     (
	 *         name=FQN 
	 *         coomRef=[ComponentOnOffManifest|FQN] 
	 *         transTimeoutInMilliseconds=INT? 
	 *         (componentTransitions+=ComponentTransition | nodeStateAssociations+=NodeStateAssociation | componentStates+=ComponentState | features+=Feature)*
	 *     )
	 */
	protected void sequence_ClientConfiguration(ISerializationContext context, ClientConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentState returns ComponentState
	 *
	 * Constraint:
	 *     (
	 *         (featureDependencies=FeatureDependency | transitionDependencies=TransitionDependency)? 
	 *         (state=[State|FQN] stateDependencies=StateDependency?)?
	 *     )+
	 */
	protected void sequence_ComponentState(ISerializationContext context, ComponentState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentTransition returns ComponentTransition
	 *
	 * Constraint:
	 *     (essential?='essential'? transition=[Transition|FQN] timeoutInMilliseconds=INT? maxretries=INT?)
	 */
	protected void sequence_ComponentTransition(ISerializationContext context, ComponentTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureDependency returns FeatureDependency
	 *
	 * Constraint:
	 *     (features+=[Feature|FQN] features+=[Feature|FQN]*)
	 */
	protected void sequence_FeatureDependency(ISerializationContext context, FeatureDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Feature
	 *
	 * Constraint:
	 *     (name=ID featureStates+=[State|FQN] featureStates+=[State|FQN]*)
	 */
	protected void sequence_Feature(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatesPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatesPackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeStateAssociation returns NodeStateAssociation
	 *
	 * Constraint:
	 *     (nodeState=[NodeState|ID] clientState=[State|FQN])
	 */
	protected void sequence_NodeStateAssociation(ISerializationContext context, NodeStateAssociation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatesPackage.Literals.NODE_STATE_ASSOCIATION__NODE_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatesPackage.Literals.NODE_STATE_ASSOCIATION__NODE_STATE));
			if (transientValues.isValueTransient(semanticObject, StatesPackage.Literals.NODE_STATE_ASSOCIATION__CLIENT_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatesPackage.Literals.NODE_STATE_ASSOCIATION__CLIENT_STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeStateAssociationAccess().getNodeStateNodeStateIDTerminalRuleCall_1_0_1(), semanticObject.eGet(StatesPackage.Literals.NODE_STATE_ASSOCIATION__NODE_STATE, false));
		feeder.accept(grammarAccess.getNodeStateAssociationAccess().getClientStateStateFQNParserRuleCall_3_0_1(), semanticObject.eGet(StatesPackage.Literals.NODE_STATE_ASSOCIATION__CLIENT_STATE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeStateConfiguration returns NodeStateConfiguration
	 *
	 * Constraint:
	 *     (
	 *         (name=FQN ((imports+=Import+ clientConfig+=ClientConfiguration+) | clientConfig+=ClientConfiguration+)) | 
	 *         (((name=FQN imports+=Import+) | imports+=Import+)? nsd=NodeStateDiagram clientConfig+=ClientConfiguration+) | 
	 *         (imports+=Import+ clientConfig+=ClientConfiguration+) | 
	 *         clientConfig+=ClientConfiguration+
	 *     )?
	 */
	protected void sequence_NodeStateConfiguration(ISerializationContext context, NodeStateConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeStateDiagram returns NodeStateDiagram
	 *
	 * Constraint:
	 *     (gEdgeWeight=INT? gTransitionTimeoutInMilliseconds=INT? (nodeStates+=NodeState | nodeTransitions+=NodeTransition)*)
	 */
	protected void sequence_NodeStateDiagram(ISerializationContext context, NodeStateDiagram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeState returns NodeState
	 *
	 * Constraint:
	 *     (initial?='initial'? name=ID)
	 */
	protected void sequence_NodeState(ISerializationContext context, NodeState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeTransition returns NodeTransition
	 *
	 * Constraint:
	 *     (
	 *         essential?='essential'? 
	 *         name=ID 
	 *         fromState=[NodeState|ID] 
	 *         toState=[NodeState|ID] 
	 *         edgeweight=INT? 
	 *         timeoutInMilliseconds=INT?
	 *     )
	 */
	protected void sequence_NodeTransition(ISerializationContext context, NodeTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateDependency returns StateDependency
	 *
	 * Constraint:
	 *     (states+=[State|FQN] states+=[State|FQN]*)
	 */
	protected void sequence_StateDependency(ISerializationContext context, StateDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransitionDependency returns TransitionDependency
	 *
	 * Constraint:
	 *     (transistions+=[Transition|FQN] transistions+=[Transition|FQN]*)
	 */
	protected void sequence_TransitionDependency(ISerializationContext context, TransitionDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
