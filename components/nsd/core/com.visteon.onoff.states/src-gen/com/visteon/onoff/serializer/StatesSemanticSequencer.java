/*
 * generated by Xtext 2.13.0
 */
package com.visteon.onoff.serializer;

import com.google.inject.Inject;
import com.visteon.onoff.services.StatesGrammarAccess;
import com.visteon.onoff.states.ClientConfiguration;
import com.visteon.onoff.states.ComponentFeature;
import com.visteon.onoff.states.ComponentState;
import com.visteon.onoff.states.ComponentTransition;
import com.visteon.onoff.states.FeatureDependency;
import com.visteon.onoff.states.Import;
import com.visteon.onoff.states.NodeState;
import com.visteon.onoff.states.NodeStateAssociation;
import com.visteon.onoff.states.NodeStateConfiguration;
import com.visteon.onoff.states.NodeStateDiagram;
import com.visteon.onoff.states.NodeTransition;
import com.visteon.onoff.states.StateDependency;
import com.visteon.onoff.states.StatesPackage;
import com.visteon.onoff.states.TransitionDependency;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class StatesSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private StatesGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == StatesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StatesPackage.CLIENT_CONFIGURATION:
				sequence_ClientConfiguration(context, (ClientConfiguration) semanticObject); 
				return; 
			case StatesPackage.COMPONENT_FEATURE:
				sequence_ComponentFeature(context, (ComponentFeature) semanticObject); 
				return; 
			case StatesPackage.COMPONENT_STATE:
				sequence_ComponentState(context, (ComponentState) semanticObject); 
				return; 
			case StatesPackage.COMPONENT_TRANSITION:
				sequence_ComponentTransition(context, (ComponentTransition) semanticObject); 
				return; 
			case StatesPackage.FEATURE_DEPENDENCY:
				sequence_FeatureDependency(context, (FeatureDependency) semanticObject); 
				return; 
			case StatesPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case StatesPackage.NODE_STATE:
				sequence_NodeState(context, (NodeState) semanticObject); 
				return; 
			case StatesPackage.NODE_STATE_ASSOCIATION:
				sequence_NodeStateAssociation(context, (NodeStateAssociation) semanticObject); 
				return; 
			case StatesPackage.NODE_STATE_CONFIGURATION:
				sequence_NodeStateConfiguration(context, (NodeStateConfiguration) semanticObject); 
				return; 
			case StatesPackage.NODE_STATE_DIAGRAM:
				sequence_NodeStateDiagram(context, (NodeStateDiagram) semanticObject); 
				return; 
			case StatesPackage.NODE_TRANSITION:
				sequence_NodeTransition(context, (NodeTransition) semanticObject); 
				return; 
			case StatesPackage.STATE_DEPENDENCY:
				sequence_StateDependency(context, (StateDependency) semanticObject); 
				return; 
			case StatesPackage.TRANSITION_DEPENDENCY:
				sequence_TransitionDependency(context, (TransitionDependency) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ClientConfiguration returns ClientConfiguration
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         coomRef=[ComponentOnOffManifest|ID] 
	 *         transTimeoutInMilliseconds=INT? 
	 *         (transitions+=ComponentTransition | states+=ComponentState | features+=ComponentFeature | nodeStateAssociations+=NodeStateAssociation)*
	 *     )
	 */
	protected void sequence_ClientConfiguration(ISerializationContext context, ClientConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentFeature returns ComponentFeature
	 *
	 * Constraint:
	 *     (name=ID states+=[State|FQN] states+=[State|FQN]*)
	 */
	protected void sequence_ComponentFeature(ISerializationContext context, ComponentFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentState returns ComponentState
	 *
	 * Constraint:
	 *     (state=[State|FQN] (stateDependency=StateDependency | featureDependency=FeatureDependency | transitionDependency=TransitionDependency)*)
	 */
	protected void sequence_ComponentState(ISerializationContext context, ComponentState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentTransition returns ComponentTransition
	 *
	 * Constraint:
	 *     (
	 *         essential?='essential'? 
	 *         transition=[Transition|FQN] 
	 *         timeoutInMilliseconds=INT? 
	 *         maxretries=INT? 
	 *         (stateDependency=StateDependency | featureDependency=FeatureDependency)*
	 *     )
	 */
	protected void sequence_ComponentTransition(ISerializationContext context, ComponentTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureDependency returns FeatureDependency
	 *
	 * Constraint:
	 *     (features+=[ComponentFeature|ID] features+=[ComponentFeature|ID]*)
	 */
	protected void sequence_FeatureDependency(ISerializationContext context, FeatureDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatesPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatesPackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeStateAssociation returns NodeStateAssociation
	 *
	 * Constraint:
	 *     (clientState=[State|FQN] states+=[NodeState|ID] states+=[NodeState|ID]*)
	 */
	protected void sequence_NodeStateAssociation(ISerializationContext context, NodeStateAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeStateConfiguration returns NodeStateConfiguration
	 *
	 * Constraint:
	 *     (imports+=Import* nsd=NodeStateDiagram clientConfig+=ClientConfiguration*)
	 */
	protected void sequence_NodeStateConfiguration(ISerializationContext context, NodeStateConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeStateDiagram returns NodeStateDiagram
	 *
	 * Constraint:
	 *     (gEdgeWeight=INT? gTransitionTimeoutInMilliseconds=INT? (states+=NodeState | transitions+=NodeTransition)*)
	 */
	protected void sequence_NodeStateDiagram(ISerializationContext context, NodeStateDiagram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeState returns NodeState
	 *
	 * Constraint:
	 *     (initial?='initial'? name=ID)
	 */
	protected void sequence_NodeState(ISerializationContext context, NodeState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeTransition returns NodeTransition
	 *
	 * Constraint:
	 *     (
	 *         essential?='essential'? 
	 *         name=ID 
	 *         fromState=[NodeState|ID] 
	 *         toState=[NodeState|ID] 
	 *         edgeweight=INT? 
	 *         timeoutInMilliseconds=INT?
	 *     )
	 */
	protected void sequence_NodeTransition(ISerializationContext context, NodeTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateDependency returns StateDependency
	 *
	 * Constraint:
	 *     (states+=[State|FQN] states+=[State|FQN]*)
	 */
	protected void sequence_StateDependency(ISerializationContext context, StateDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransitionDependency returns TransitionDependency
	 *
	 * Constraint:
	 *     (transistions+=[Transition|FQN] transistions+=[Transition|FQN]*)
	 */
	protected void sequence_TransitionDependency(ISerializationContext context, TransitionDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
